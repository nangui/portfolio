---
import { getSectionLocale, setSectionLocale, getAvailableLocales, getLocaleLabel, getLocaleCode, type Locale } from '@utils/i18n/useSectionI18n';
import { getTranslation, translations, type SectionTranslations } from '@utils/i18n/translations';

interface Props {
  sectionId: string;
  defaultLocale?: Locale;
  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
}

const { 
  sectionId, 
  defaultLocale = 'fr',
  position = 'top-right'
} = Astro.props;

const currentLocale = getSectionLocale(sectionId, defaultLocale);
const availableLocales = getAvailableLocales();

// Position classes
const positionClasses = {
  'top-right': 'top-4 right-4',
  'top-left': 'top-4 left-4',
  'bottom-right': 'bottom-4 right-4',
  'bottom-left': 'bottom-4 left-4',
};
---

<div class={`section-translator absolute ${positionClasses[position]} z-10`} data-section-id={sectionId} data-translator-instance>
  <button
    class="lang-toggle-button group flex items-center gap-2 px-3 py-2 bg-secondary/80 backdrop-blur-sm border border-border-default rounded-lg hover:border-accent hover:bg-secondary transition-all duration-300 focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-accent"
    aria-label={`Changer la langue de la section ${sectionId}`}
    aria-expanded="false"
    aria-haspopup="true"
    data-lang-toggle={sectionId}
  >
    <svg class="w-4 h-4 text-secondary group-hover:text-accent transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"></path>
    </svg>
    <span class="text-sm font-medium text-secondary group-hover:text-accent transition-colors" data-current-locale={sectionId}>
      {getLocaleCode(currentLocale)}
    </span>
    <svg class="w-3 h-3 text-secondary group-hover:text-accent transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
    </svg>
  </button>
  
  <div 
    class="lang-menu hidden absolute top-full mt-2 right-0 bg-secondary border border-border-default rounded-lg shadow-lg overflow-hidden min-w-[120px]"
    data-lang-menu={sectionId}
    role="menu"
  >
    {availableLocales.map((locale: Locale) => (
      <button
        class={`lang-option w-full text-left px-4 py-2 text-sm transition-colors hover:bg-tertiary hover:text-accent ${
          locale === currentLocale 
            ? 'bg-accent/10 text-accent font-medium' 
            : 'text-secondary'
        }`}
        data-locale={locale}
        data-lang-option={sectionId}
        role="menuitem"
        aria-label={`Changer en ${getLocaleLabel(locale)}`}
      >
        <span class="font-medium mr-2">{getLocaleCode(locale)}</span>
        <span class="text-xs opacity-70">{getLocaleLabel(locale)}</span>
      </button>
    ))}
  </div>
</div>

<script>
  import { gsap } from 'gsap';
  import { splitTextToChars } from '../../utils/i18n/splitText';
  import { setSectionLocale, getSectionLocale, type Locale } from '../../utils/i18n/useSectionI18n';
  
  // Import translations for client-side use
  // We need to access translations in the client script
  const translationsData = {
    hero: {
      fr: { name: 'Adonai Nangui', title: 'Senior Frontend Engineer / Tech Lead', tagline: 'Je choisis les bons outils pour les bons problèmes', ctaProjects: 'Voir mes projets', ctaContact: 'Me contacter' },
      en: { name: 'Adonai Nangui', title: 'Senior Frontend Engineer / Tech Lead', tagline: 'I choose the right tools for the right problems', ctaProjects: 'View my projects', ctaContact: 'Contact me' }
    },
    about: {
      fr: { heading: 'À propos', paragraph1: 'Senior Software Engineer & Tech Lead avec plus de 9 ans d\'expérience, je me spécialise dans la conception et la mise en œuvre de systèmes web scalables, performants et maintenables. J\'interviens aussi bien sur l\'architecture frontend que sur l\'intégration de systèmes de paiement et le développement d\'applications métier complexes, du temps réel au backend.', paragraph2: 'J\'ai dirigé des équipes de développement, piloté des choix architecturaux structurants et participé activement aux décisions métier, avec une approche pragmatique orientée impact business. Je porte une attention particulière à la qualité du code, à la performance, à la maintenabilité long terme et à l\'alignement entre enjeux techniques et objectifs produit.' },
      en: { heading: 'About', paragraph1: 'Senior Software Engineer & Tech Lead with over 9 years of experience, I specialize in designing and implementing scalable, performant, and maintainable web systems. I work on both frontend architecture and payment system integration, as well as complex business applications, from real-time to backend.', paragraph2: 'I have led development teams, driven structuring architectural choices, and actively participated in business decisions, with a pragmatic approach focused on business impact. I pay particular attention to code quality, performance, long-term maintainability, and alignment between technical challenges and product goals.' }
    }
  };
  
  function getTranslationClient(sectionId: string, key: string, locale: Locale): string {
    const section = translationsData[sectionId as keyof typeof translationsData];
    if (!section) return key;
    const translation = section[locale];
    if (!translation) return key;
    const value = translation[key as keyof typeof translation];
    return typeof value === 'string' ? value : key;
  }

  const initSectionTranslator = () => {
    // Initialize each translator instance separately
    const translatorInstances = document.querySelectorAll('[data-translator-instance]');
    
    translatorInstances.forEach((instance) => {
      const sectionId = instance.getAttribute('data-section-id');
      if (!sectionId) return;

      const toggleButton = instance.querySelector(`[data-lang-toggle="${sectionId}"]`) as HTMLElement;
      const langMenu = instance.querySelector(`[data-lang-menu="${sectionId}"]`) as HTMLElement;
      const langOptions = instance.querySelectorAll(`[data-lang-option="${sectionId}"]`) as NodeListOf<HTMLElement>;
      const currentLocaleSpan = instance.querySelector(`[data-current-locale="${sectionId}"]`) as HTMLElement;

      if (!toggleButton || !langMenu) {
        console.warn(`SectionTranslator: Missing elements for section ${sectionId}`);
        return;
      }

      // Helper function to update UI to reflect current locale
      const updateUIForLocale = (locale: Locale) => {
        // Update button text
        const localeSpan = instance.querySelector(`[data-current-locale="${sectionId}"]`) as HTMLElement;
        if (localeSpan) {
          localeSpan.textContent = locale.toUpperCase();
        }

        // Update menu options styling
        const options = instance.querySelectorAll(`[data-lang-option="${sectionId}"]`) as NodeListOf<HTMLElement>;
        options.forEach((option) => {
          const optionLocale = option.getAttribute('data-locale') as Locale;
          if (optionLocale === locale) {
            option.classList.add('bg-accent/10', 'text-accent', 'font-medium');
            option.classList.remove('text-secondary');
          } else {
            option.classList.remove('bg-accent/10', 'text-accent', 'font-medium');
            option.classList.add('text-secondary');
          }
        });
      };

      // Initialize UI with current locale
      const initialLocale = getSectionLocale(sectionId, 'fr');
      updateUIForLocale(initialLocale);

      // Toggle menu
      toggleButton.addEventListener('click', (e) => {
        e.stopPropagation();
        const isHidden = langMenu.classList.contains('hidden');
        langMenu.classList.toggle('hidden');
        toggleButton.setAttribute('aria-expanded', isHidden ? 'true' : 'false');
      });

      // Handle locale selection
      langOptions.forEach((option) => {
        option.addEventListener('click', async (e) => {
          e.stopPropagation();
          const newLocale = option.getAttribute('data-locale') as Locale;
          const currentLocale = getSectionLocale(sectionId, 'fr');

          if (newLocale === currentLocale) {
            langMenu.classList.add('hidden');
            toggleButton.setAttribute('aria-expanded', 'false');
            return;
          }

          // Update UI immediately (optimistic update)
          updateUIForLocale(newLocale);

          // Close menu
          langMenu.classList.add('hidden');
          toggleButton.setAttribute('aria-expanded', 'false');

          // Animate text translation
          await animateTextTranslation(sectionId, currentLocale, newLocale);

          // Save locale (after animation completes)
          setSectionLocale(sectionId, newLocale);
          
          // Ensure UI is still correct after save
          updateUIForLocale(newLocale);
        });
      });
    });

    // Close menus when clicking outside (global handler)
    document.addEventListener('click', (e) => {
      translatorInstances.forEach((instance) => {
        const sectionId = instance.getAttribute('data-section-id');
        if (!sectionId) return;
        
        const langMenu = instance.querySelector(`[data-lang-menu="${sectionId}"]`) as HTMLElement;
        const toggleButton = instance.querySelector(`[data-lang-toggle="${sectionId}"]`) as HTMLElement;
        
        if (langMenu && toggleButton && 
            !langMenu.contains(e.target as Node) && 
            !toggleButton.contains(e.target as Node)) {
          langMenu.classList.add('hidden');
          toggleButton.setAttribute('aria-expanded', 'false');
        }
      });
    });
  };

  /**
   * Animate text translation with GSAP
   */
  async function animateTextTranslation(
    sectionId: string,
    oldLocale: Locale,
    newLocale: Locale
  ): Promise<void> {
    const section = document.getElementById(sectionId);
    if (!section) {
      console.warn(`Section ${sectionId} not found`);
      return;
    }

    // Find all elements with data-i18n-key attribute
    // Use a more comprehensive selector to find elements even if they're nested
    let translatableElements = Array.from(section.querySelectorAll('[data-i18n-key]')) as HTMLElement[];
    
    // If no elements found, try to find them in nested structures (like TextDistortion)
    if (translatableElements.length === 0) {
      // Try finding by traversing all elements in the section
      const allElements = section.querySelectorAll('*');
      translatableElements = Array.from(allElements).filter((el) => {
        return el.hasAttribute('data-i18n-key');
      }) as HTMLElement[];
    }
    
    if (translatableElements.length === 0) {
      console.warn(`No translatable elements found in section ${sectionId}`, section);
      return;
    }
    
    console.log(`Found ${translatableElements.length} translatable elements in section ${sectionId}`);

    // Check if this is the About section (simple fade animation)
    const isAboutSection = sectionId === 'about';
    
    // Animate each element sequentially to avoid conflicts
    for (const element of translatableElements) {
      const key = element.getAttribute('data-i18n-key');
      if (!key) continue;

      // Get text content - handle cases where TextDistortion has modified the DOM
      let oldText = element.textContent?.trim() || '';
      
      // If element is empty or text doesn't match, try to get from inner elements
      if (!oldText || oldText.length === 0) {
        const innerText = element.innerText?.trim() || '';
        if (innerText) oldText = innerText;
      }
      
      const newText = getTranslationClient(sectionId, key, newLocale);

      if (!newText) {
        console.warn(`No translation found for key "${key}" in section "${sectionId}" for locale "${newLocale}"`);
        continue;
      }
      
      if (oldText === newText) {
        console.log(`Text unchanged for key "${key}"`);
        continue;
      }
      
      console.log(`Translating "${key}": "${oldText}" -> "${newText}"`);

      await new Promise<void>((resolve) => {
        if (isAboutSection) {
          // Simple fade animation for About section
          const tl = gsap.timeline({
            onComplete: () => {
              resolve();
            }
          });

          // Phase 1: Fade out all text at once
          tl.to(element, {
            opacity: 0,
            duration: 0.2,
            ease: 'power2.in',
          });

          // Phase 2: Replace content
          tl.call(() => {
            // Clean up any TextDistortion modifications
            element.innerHTML = '';
            element.textContent = newText;
            element.style.opacity = '0';
          });

          // Phase 3: Fade in new text
          tl.to(element, {
            opacity: 1,
            duration: 0.3,
            ease: 'power2.out',
          });
        } else {
          // Character-by-character animation for other sections (Hero, etc.)
          
          // Handle TextDistortion: find the actual text element
          // TextDistortion wraps content, so we need to find the original element
          let targetElement = element;
          
          // Check if element is inside a TextDistortion wrapper
          const textDistortionWrapper = element.closest('[data-text-distortion]');
          if (textDistortionWrapper) {
            // Find the direct child that contains the text (TextDistortion wraps the slot content)
            const directChild = textDistortionWrapper.children[0] as HTMLElement;
            if (directChild && directChild === element) {
              targetElement = element;
            } else if (directChild) {
              // The element might be nested, try to find it
              const nestedElement = directChild.querySelector(`[data-i18n-key="${key}"]`) as HTMLElement;
              if (nestedElement) {
                targetElement = nestedElement;
              }
            }
          }

          // Clean up TextDistortion modifications first
          // Remove any existing character spans
          const existingChars = targetElement.querySelectorAll('span[data-char-index]');
          if (existingChars.length > 0) {
            // Restore original structure
            targetElement.innerHTML = oldText;
          }

          // Phase 1: Split and destroy old text
          const oldChars = splitTextToChars(targetElement);
          
          if (oldChars.length === 0) {
            targetElement.textContent = newText;
            resolve();
            return;
          }

          // Create timeline for this element
          const tl = gsap.timeline({
            onComplete: () => {
              resolve();
            }
          });

          // Animate old chars out (faster)
          tl.to(oldChars, {
            opacity: 0,
            y: -30,
            rotation: -15,
            scale: 0.8,
            stagger: 0.01,
            duration: 0.15,
            ease: 'power2.in',
          });

          // Phase 2: Replace content
          tl.call(() => {
            targetElement.innerHTML = '';
            targetElement.textContent = newText;
          });

          // Phase 3: Split and animate new text in
          tl.call(() => {
            // Small delay to ensure DOM is updated
            requestAnimationFrame(() => {
              const newChars = splitTextToChars(targetElement);
              
              if (newChars.length === 0) {
                resolve();
                return;
              }

              // Set initial state
              gsap.set(newChars, {
                opacity: 0,
                y: 30,
                rotation: 15,
                scale: 0.8,
              });

              // Animate in (faster)
              gsap.to(newChars, {
                opacity: 1,
                y: 0,
                rotation: 0,
                scale: 1,
                stagger: 0.01,
                duration: 0.2,
                ease: 'power2.out',
              });
            });
          }, undefined, '+=0.05');
        }
      });
    }
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSectionTranslator);
  } else {
    initSectionTranslator();
  }

  // Reinitialize on page transitions (Astro)
  document.addEventListener('astro:page-load', initSectionTranslator);
</script>

<style>
  .section-translator {
    pointer-events: none;
  }

  .section-translator > * {
    pointer-events: auto;
  }

  .lang-menu {
    animation: fadeIn 0.2s ease-out;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(-8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  [data-i18n-key] {
    will-change: transform, opacity;
  }
</style>
