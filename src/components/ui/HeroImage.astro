---
// Use public image for Three.js texture loading
const imageUrl = '/hero-image.jpeg';
---

<div class="hero-image-container relative w-full h-full">
  <canvas 
    id="hero-image-canvas" 
    class="w-full h-full" 
    data-image-src={imageUrl}
  ></canvas>
</div>

<script>
  import * as THREE from 'three';

  // Vertex shader for 3D plane
  const vertexShader = `
    varying vec2 vUv;
    varying vec3 vPosition;
    
    void main() {
      vUv = uv;
      vPosition = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  // Fragment shader with distortion effect
  const fragmentShader = `
    uniform sampler2D uTexture;
    uniform vec2 uMouse;
    uniform float uTime;
    uniform float uDistortion;
    uniform float uIntensity;
    
    varying vec2 vUv;
    varying vec3 vPosition;
    
    void main() {
      vec2 uv = vUv;
      
      // Calculate distance from mouse position
      vec2 mouse = uMouse;
      float dist = distance(uv, mouse);
      
      // Create distortion effect
      float distortion = uDistortion * uIntensity;
      vec2 distortionOffset = (mouse - uv) * distortion * (1.0 / (dist + 0.1));
      
      // Add wave effect
      vec2 waveOffset = vec2(
        sin(vPosition.x * 0.1 + uTime) * 0.01,
        cos(vPosition.y * 0.1 + uTime) * 0.01
      );
      
      // Apply distortion
      uv += distortionOffset + waveOffset;
      
      // Sample texture with distortion
      vec4 color = texture2D(uTexture, uv);
      
      gl_FragColor = color;
    }
  `;

  const initHeroImage = () => {
    const canvas = document.getElementById('hero-image-canvas') as HTMLCanvasElement;
    if (!canvas) return;
    
    const imageSrc = canvas.getAttribute('data-image-src');
    if (!imageSrc) return;

    const container = canvas.parentElement;
    if (!container) return;

    // Get container dimensions
    const updateSize = () => {
      const rect = container.getBoundingClientRect();
      return {
        width: rect.width,
        height: rect.height,
      };
    };

    let { width, height } = updateSize();

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.z = 1;

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // Load texture
    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load(
      imageSrc,
      (loadedTexture: THREE.Texture) => {
        loadedTexture.minFilter = THREE.LinearFilter;
        loadedTexture.magFilter = THREE.LinearFilter;
      },
      undefined,
      (error: unknown) => {
        console.error('Error loading texture:', error);
      }
    );

    // Create plane geometry
    const geometry = new THREE.PlaneGeometry(2, 2, 32, 32);
    
    // Create shader material (texture will be loaded asynchronously)
    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        uTexture: { value: texture },
        uMouse: { value: new THREE.Vector2(0.5, 0.5) },
        uTime: { value: 0 },
        uDistortion: { value: 0 },
        uIntensity: { value: 0.3 },
      },
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Mouse tracking
    const mouse = new THREE.Vector2(0.5, 0.5);
    let targetDistortion = 0;
    let currentDistortion = 0;

    const handleMouseMove = (event: MouseEvent) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = (event.clientX - rect.left) / rect.width;
      mouse.y = 1 - (event.clientY - rect.top) / rect.height; // Flip Y
      
      material.uniforms.uMouse.value = mouse;
      targetDistortion = 0.15;
    };

    const handleMouseLeave = () => {
      targetDistortion = 0;
    };

    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseleave', handleMouseLeave);

    // Animation loop
    let time = 0;
    const animate = () => {
      requestAnimationFrame(animate);
      
      time += 0.01;
      material.uniforms.uTime.value = time;
      
      // Smooth distortion interpolation
      currentDistortion += (targetDistortion - currentDistortion) * 0.1;
      material.uniforms.uDistortion.value = currentDistortion;
      
      renderer.render(scene, camera);
    };

    animate();

    // Handle resize
    const handleResize = () => {
      const newSize = updateSize();
      width = newSize.width;
      height = newSize.height;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    };

    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      canvas.removeEventListener('mousemove', handleMouseMove);
      canvas.removeEventListener('mouseleave', handleMouseLeave);
      renderer.dispose();
      geometry.dispose();
      material.dispose();
      texture.dispose();
    };
  };

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHeroImage);
  } else {
    initHeroImage();
  }
</script>

<style>
  .hero-image-container {
    aspect-ratio: 1;
    max-width: 400px;
    margin: 0 auto;
  }
  
  #hero-image-canvas {
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    overflow: hidden;
  }
  
  @media (max-width: 768px) {
    .hero-image-container {
      max-width: 300px;
    }
  }
</style>
