---
---

<div id="custom-cursor-container" class="fixed inset-0 pointer-events-none z-50">
  <canvas id="custom-cursor-canvas" class="w-full h-full"></canvas>
</div>

<script>
  import * as THREE from 'three';

  const initCustomCursor = () => {
    // Only run on desktop
    if (window.innerWidth < 768) {
      return;
    }

    const canvas = document.getElementById('custom-cursor-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    const container = canvas.parentElement;
    if (!container) return;

    // Hide native cursor
    document.body.style.cursor = 'none';
    
    // Apply cursor: none to all interactive elements
    const style = document.createElement('style');
    style.textContent = `
      a, button, [role="button"], input, textarea, select {
        cursor: none !important;
      }
    `;
    document.head.appendChild(style);

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // Create sphere cursor
    const sphereGeometry = new THREE.SphereGeometry(0.08, 32, 32);
    const sphereMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ff88,
      transparent: true,
      opacity: 0.8,
    });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    scene.add(sphere);

    // Create particles around sphere
    const particlesGeometry = new THREE.BufferGeometry();
    const particleCount = 30;
    const positions = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount * 3; i++) {
      positions[i] = (Math.random() - 0.5) * 0.5;
    }
    
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const particlesMaterial = new THREE.PointsMaterial({
      color: 0x00cc6a,
      size: 0.02,
      transparent: true,
      opacity: 0.6,
    });
    
    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    sphere.add(particles);

    // Mouse tracking
    const mouse = new THREE.Vector2();
    const targetPosition = new THREE.Vector3();
    let isHovering = false;

    // Raycaster for detecting interactive elements
    const raycaster = new THREE.Raycaster();
    const interactiveElements = document.querySelectorAll('a, button, [role="button"], input, textarea, select');

    const updateMousePosition = (event: MouseEvent) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Convert to world space
      const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
      vector.unproject(camera);
      const dir = vector.sub(camera.position).normalize();
      const distance = -camera.position.z / dir.z;
      targetPosition.copy(camera.position).add(dir.multiplyScalar(distance));

      // Check if hovering over interactive element
      const target = event.target;
      // closest() only works on Element, not on Text nodes or other types
      if (target instanceof Element) {
        isHovering = target.closest('a, button, [role="button"], input, textarea, select') !== null;
      } else {
        isHovering = false;
      }
    };

    window.addEventListener('mousemove', updateMousePosition);

    // Animation loop with visibility management
    let time = 0;
    let animationFrameId: number | null = null;
    let isAnimating = true;

    const animate = () => {
      // Only animate if page is visible
      if (document.hidden) {
        animationFrameId = null;
        isAnimating = false;
        return;
      }

      animationFrameId = requestAnimationFrame(animate);
      isAnimating = true;

      time += 0.01;

      // Smooth cursor movement
      sphere.position.lerp(targetPosition, 0.15);

      // Rotate particles
      particles.rotation.y += 0.01;
      particles.rotation.x += 0.005;

      // Scale and color change on hover
      const targetScale = isHovering ? 1.5 : 1;
      const currentScale = sphere.scale.x;
      sphere.scale.setScalar(currentScale + (targetScale - currentScale) * 0.1);

      // Change color on hover
      const targetColor = isHovering ? 0x00cc6a : 0x00ff88;
      const currentColor = sphereMaterial.color.getHex();
      if (currentColor !== targetColor) {
        sphereMaterial.color.setHex(
          currentColor + Math.sign(targetColor - currentColor) * 0x001111
        );
      }

      // Pulsating effect
      sphereMaterial.opacity = 0.7 + Math.sin(time * 2) * 0.1;

      renderer.render(scene, camera);
    };

    // Start animation
    animate();

    // Handle visibility changes
    const handleVisibilityChange = () => {
      if (document.hidden) {
        // Page hidden - stop animation
        if (animationFrameId !== null) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        isAnimating = false;
      } else {
        // Page visible - resume animation
        if (!isAnimating) {
          animate();
        }
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    // Handle resize
    const handleResize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    };

    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('mousemove', updateMousePosition);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
      }
      renderer.dispose();
      sphereGeometry.dispose();
      sphereMaterial.dispose();
      particlesGeometry.dispose();
      particlesMaterial.dispose();
      document.body.style.cursor = '';
      style.remove();
    };
  };

  // Initialize when DOM is ready
  const init = () => {
    // Cleanup any existing instance first
    const existingContainer = document.getElementById('custom-cursor-container');
    if (existingContainer) {
      // Try to cleanup if there's a cleanup function stored
      const cleanup = (existingContainer as any).__cleanup;
      if (cleanup && typeof cleanup === 'function') {
        cleanup();
      }
    }
    initCustomCursor();
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Reinitialize on Astro page transitions
  document.addEventListener('astro:page-load', init);
</script>

<style>
  #custom-cursor-container {
    pointer-events: none;
    user-select: none;
  }

  #custom-cursor-canvas {
    display: block;
  }

  @media (max-width: 768px) {
    #custom-cursor-container {
      display: none;
    }
  }
</style>
